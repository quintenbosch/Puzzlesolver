{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Cryptarithmetic puzzlesolver by Quinten Bosch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Enter your puzzle here... (like this: TO + GO = OUT)\n",
      "TWO + TWO = FOUR -> 765 + 765 = 1530\n",
      "T = 7\n",
      "U = 3\n",
      "O = 5\n",
      "R = 0\n",
      "F = 1\n",
      "W = 6\n"
     ]
    }
   ],
   "source": [
    "#Import the necessary libraries\n",
    "import re\n",
    "from simpleai.search import CspProblem, backtrack\n",
    "\n",
    "#Print some text to indicate when and what to insert\n",
    "print(\"Enter your puzzle here... (like this: TO + GO = OUT)\")\n",
    "\n",
    "#Put the input in a variable 'puzzle', change all letters to uppercase and remove the spaces using the re library\n",
    "puzzle = input().upper()\n",
    "puzzle_no_spaces = re.sub(\" \", \"\", puzzle)\n",
    "\n",
    "#Search the kind of method used\n",
    "for letter in puzzle_no_spaces:\n",
    "  if letter in [\"+\", \"-\", \"*\", \"/\"]:\n",
    "    method = letter\n",
    "\n",
    "#Identify the different parts of the puzzle\n",
    "#First part until the method\n",
    "part1 = tuple(puzzle_no_spaces[:puzzle_no_spaces.index(method)])\n",
    "#Second part between the method and the equal sign\n",
    "part2 = tuple(puzzle_no_spaces[puzzle_no_spaces.index(method)+1:puzzle_no_spaces.index(\"=\")])\n",
    "#Third part after the equal sign\n",
    "part3 = tuple(puzzle_no_spaces[puzzle_no_spaces.index(\"=\")+1:])\n",
    "\n",
    "#Remove the signs from the puzzle with the re library\n",
    "clean_puzzle = re.sub(\"[-+*/=]\", \"\", puzzle_no_spaces)\n",
    "\n",
    "#Create a domain variable, where we will add the values later on\n",
    "domains = {}\n",
    "\n",
    "#Empty list, where we will add all letters to later on\n",
    "chars=[]\n",
    "\n",
    "#Loop over the first part of the puzzle\n",
    "#If we come across the first letter ->\n",
    "#a list from 1 to 10 (10 excluded) will be added to the domains variable\n",
    "#If it is not the first letter ->\n",
    "#a list from 0 to 10 (10 excluded) will be added to the domains variable\n",
    "for letter in part1:\n",
    "  if letter == part1[0]:\n",
    "    domains[letter] = list(range(1,10))\n",
    "    chars.append(letter) #Letter will be added to the chars variable\n",
    "  else:\n",
    "    domains[letter] = list(range(0,10))\n",
    "    chars.append(letter) #Letter will be added to the chars variable\n",
    "\n",
    "#Loop over the second part of the puzzle\n",
    "#If we come across the first letter ->\n",
    "#a list from 1 to 10 (10 excluded) will be added to the domains variable\n",
    "#If it is not the first letter ->\n",
    "#a list from 0 to 10 (10 excluded) will be added to the domains variable\n",
    "for letter in part2:\n",
    "  if letter == part2[0]:\n",
    "    domains[letter] = list(range(1,10))\n",
    "    chars.append(letter) #Letter will be added to the chars variable\n",
    "  else:\n",
    "    domains[letter] = list(range(0,10))\n",
    "    chars.append(letter) #Letter will be added to the chars variable\n",
    "\n",
    "#Loop over the third part of the puzzle\n",
    "#If we come across the first letter ->\n",
    "#a list from 1 to 10 (10 excluded) will be added to the domains variable\n",
    "#If it is not the first letter ->\n",
    "#a list from 0 to 10 (10 excluded) will be added to the domains variable\n",
    "for letter in part3:\n",
    "  if letter == part3[0]:\n",
    "    domains[letter] = list(range(1,10))\n",
    "    chars.append(letter) #Letter will be added to the chars variable\n",
    "  else:\n",
    "    domains[letter] = list(range(0,10))\n",
    "    chars.append(letter) #Letter will be added to the chars variable\n",
    "\n",
    "#Remove all duplicates from the chars variable\n",
    "chars = list(set(chars))\n",
    "\n",
    "#Create the constraints\n",
    "\n",
    "#Create a constraint to verify if all characters are unique\n",
    "#by comparing the length of the filtered list with the normal list\n",
    "def constraint_unique(chars, values):\n",
    "  return len(values) == len(set(values))\n",
    "\n",
    "#Create a constraint to ensure that factor1 + factor2 = result\n",
    "def constraint_add(chars, values): #Kan geen 3 lijsten aanpakken, dus chars ipv characters1,2,3. En al helemaal niet de variables die der eerst stond, want die hebben geen waarde (niet aangeroepen in domains)\n",
    "  #We create 3 variables which we will later on use in our for loops\n",
    "  factor1 = \"\"\n",
    "  factor2 = \"\"\n",
    "  result = \"\"\n",
    "\n",
    "  #Loop over the first part of the puzzle and add each letter to the factor1 variable\n",
    "  for letter in part1:\n",
    "    index = chars.index(letter)\n",
    "    factor1 += str(values[index])\n",
    "  \n",
    "  #Loop over the second part of the puzzle and add each letter to the factor2 variable\n",
    "  for letter in part2:\n",
    "    index = chars.index(letter)\n",
    "    factor2 += str(values[index])\n",
    "\n",
    "  #Loop over the third part of the puzzle and add each letter to the result variable\n",
    "  for letter in part3:\n",
    "    index = chars.index(letter)\n",
    "    result += str(values[index])\n",
    "\n",
    "  #Convert these factors to integer, so we can calculate with them\n",
    "  factor1 = int(factor1)\n",
    "  factor2 = int(factor2)\n",
    "  result = int(result)\n",
    "\n",
    "  #We add the 2 factors together which must equal the result\n",
    "  return (factor1 + factor2) == result\n",
    "\n",
    "#Create a constraint to ensure that factor1 - factor2 = result\n",
    "def constraint_substract(chars, values):\n",
    "  #We create 3 variables which we will later on use in our for loops\n",
    "  factor1 = \"\"\n",
    "  factor2 = \"\"\n",
    "  result = \"\"\n",
    "\n",
    "  #Loop over the first part of the puzzle and add each letter to the factor1 variable\n",
    "  for letter in part1:\n",
    "    index = chars.index(letter)\n",
    "    factor1 += str(values[index])\n",
    "  \n",
    "  #Loop over the second part of the puzzle and add each letter to the factor2 variable\n",
    "  for letter in part2:\n",
    "    index = chars.index(letter)\n",
    "    factor2 += str(values[index])\n",
    "\n",
    "  #Loop over the third part of the puzzle and add each letter to the result variable\n",
    "  for letter in part3:\n",
    "    index = chars.index(letter)\n",
    "    result += str(values[index])\n",
    "\n",
    "  #Convert these factors to integer, so we can calculate with them\n",
    "  factor1 = int(factor1)\n",
    "  factor2 = int(factor2)\n",
    "  result = int(result)\n",
    "\n",
    "  #We substract factor 2 from factor 1 which must equal the result\n",
    "  return (factor1 - factor2) == result\n",
    "\n",
    "#Create a constraint to ensure that factor1 * factor2 = result\n",
    "def constraint_multiply(chars, values):\n",
    "  #We create 3 variables which we will later on use in our for loops\n",
    "  factor1 = \"\"\n",
    "  factor2 = \"\"\n",
    "  result = \"\"\n",
    "\n",
    "  #Loop over the first part of the puzzle and add each letter to the factor1 variable\n",
    "  for letter in part1:\n",
    "    index = chars.index(letter)\n",
    "    factor1 += str(values[index])\n",
    "  \n",
    "  #Loop over the second part of the puzzle and add each letter to the factor2 variable\n",
    "  for letter in part2:\n",
    "    index = chars.index(letter)\n",
    "    factor2 += str(values[index])\n",
    "\n",
    "  #Loop over the third part of the puzzle and add each letter to the result variable\n",
    "  for letter in part3:\n",
    "    index = chars.index(letter)\n",
    "    result += str(values[index])\n",
    "\n",
    "  #Convert these factors to integer, so we can calculate with them\n",
    "  factor1 = int(factor1)\n",
    "  factor2 = int(factor2)\n",
    "  result = int(result)\n",
    "\n",
    "  #We multiply factor 1 with factor 2 which must equal the result\n",
    "  return (factor1 * factor2) == result\n",
    "\n",
    "#Create a constraint to ensure that factor1 / factor2 = result\n",
    "def constraint_divide(chars, values):\n",
    "  #We create 3 variables which we will later on use in our for loops\n",
    "  factor1 = \"\"\n",
    "  factor2 = \"\"\n",
    "  result = \"\"\n",
    "\n",
    "  #Loop over the first part of the puzzle and add each letter to the factor1 variable\n",
    "  for letter in part1:\n",
    "    index = chars.index(letter)\n",
    "    factor1 += str(values[index])\n",
    "  \n",
    "  #Loop over the second part of the puzzle and add each letter to the factor2 variable\n",
    "  for letter in part2:\n",
    "    index = chars.index(letter)\n",
    "    factor2 += str(values[index])\n",
    "\n",
    "  #Loop over the third part of the puzzle and add each letter to the result variable\n",
    "  for letter in part3:\n",
    "    index = chars.index(letter)\n",
    "    result += str(values[index])\n",
    "\n",
    "  #Convert these factors to integer, so we can calculate with them\n",
    "  factor1 = int(factor1)\n",
    "  factor2 = int(factor2)\n",
    "  result = int(result)\n",
    "\n",
    "  #We substract factor 2 from factor 1 which must equal the result\n",
    "  return (factor1 / factor2) == result\n",
    "\n",
    "#If the + was used, we use the constraint_add\n",
    "if method == \"+\":\n",
    "  constraints = [\n",
    "    #Use all characters in the puzzle together with the constraint_unique to ensure they are unique\n",
    "    (chars, constraint_unique),\n",
    "    #Use all characters in the puzzle together with the constraint_add to ensure factor1 + factor2 equals result\n",
    "    (chars, constraint_add), \n",
    "  ]\n",
    "\n",
    "#If the - was used, we use the constraint_substract\n",
    "elif method == \"-\":\n",
    "  constraints = [\n",
    "    #Use all characters in the puzzle together with the constraint_unique to ensure they are unique\n",
    "    (chars, constraint_unique),\n",
    "    #Use all characters in the puzzle together with the constraint_substract to ensure factor1 - factor2 equals result\n",
    "    (chars, constraint_substract),\n",
    "  ]\n",
    "\n",
    "#If the * was used, we use the constraint_multiply\n",
    "elif method == \"*\":\n",
    "  constraints = [\n",
    "    #Use all characters in the puzzle together with the constraint_unique to ensure they are unique\n",
    "    (chars, constraint_unique),\n",
    "    #Use all characters in the puzzle together with the constraint_multiply to ensure factor1 * factor2 equals result\n",
    "    (chars, constraint_multiply),\n",
    "  ]\n",
    "\n",
    "#If the / was used, we use the constraint_divide\n",
    "elif method == \"/\":\n",
    "  constraints = [\n",
    "    #Use all characters in the puzzle together with the constraint_unique to ensure they are unique\n",
    "    (chars, constraint_unique),\n",
    "    #Use all characters in the puzzle together with the constraint_divide to ensure factor1 / factor2 equals result\n",
    "    (chars, constraint_divide),\n",
    "  ]\n",
    "\n",
    "#If no valid method was used we return \"No valid method\"\n",
    "else:\n",
    "  print(\"No valid method\")\n",
    "\n",
    "\n",
    "#Use the CspProblem library and the backtrack library to solve the problem\n",
    "problem = CspProblem(chars, domains, constraints)\n",
    "output = backtrack(problem)\n",
    "\n",
    "#Check if there is a solution\n",
    "#When a solution is found, print it in the right format\n",
    "if output:\n",
    "  #Create an empty solved_puzzle variable, where we will later on add letters to\n",
    "  solved_puzzle = \"\"\n",
    "  #Loop over all the letters in the puzzle and add the corresponding value from the solution to the solved_puzzle variable\n",
    "  for letter in puzzle:\n",
    "    if letter in output:\n",
    "      solved_puzzle += str(output[letter])\n",
    "      #If we come across a space, +, -, *, /, =, we just add them as they are\n",
    "    elif letter in [\"+\", \"-\", \"*\", \"/\", \"=\", \" \"]:\n",
    "      solved_puzzle += letter\n",
    "  #Print out the original and the converted one\n",
    "  print(puzzle, \"->\", solved_puzzle)\n",
    "  #Loop over all the keys in the solution and print their corresponding values\n",
    "  for key in output:\n",
    "    print(key, \"=\", output[key])\n",
    "#When no solution is found, print \"No solution found\"\n",
    "else:\n",
    "  print(\"No solution found\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.8"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
